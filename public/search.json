[{"title":"Docker","url":"/2021/04/02/Docker/","content":"# Docker使用\n\n`service docker start`启动\n\n## Docker容器命令\n\n`docker run[OPTIONS]IMAGE[COMMAND][ARG...]`新建并启动新的容器\n\n> OPTIONS说明：\n>\n> --name=\"new name\":为容器指定一个名称\n>\n> -d:后台运行容器并返回容器ID\n>\n> -i:以交互模式运行容器\n>\n> -t:为容器重新分配一个伪终端\n>\n> -p:主机端口:docker容器端口\n>\n> -P:随机分配端口\n\n`docker ps[OPTIONS]`查看容器\n\n> OPTIONS说明：\n>\n> -a:列出当前所有活跃容器以及曾运行过的容器\n>\n> -l:显示最近创建的容器\n>\n> -n:显示最近n个创建的容器\n>\n> -q:静默模式，只显示容器编号\n>\n> --no-trunc:不截断输出\n\n`exit`停止并退出当前容器\n\n`ctrl`+`P`+`Q`容器不停止退出\n\n`docker start+container name/container ID` 启动容器\n\n`docker restart+container name/container ID` 重新启动容器\n\n`docker stop+container name/container ID` 停止容器\n\n`docker kill+container name/container ID` 强制停止容器\n\n`docker rm+container name/container ID` 删除已停止的某一容器\n\n`docker -rm -f+container name/container ID` 删除正在运行的容器\n\n`docker logs -f -t --tail` -t加入时间戳 -f跟随最新的打印日志 --tail数字显示最后多少条\n\n`docker top+container ID` 查看容器内运行的进程\n\n`docker inspect+container ID` 查看容器内部细节\n\n`docker attach+container ID`  重新进入容器，启动命令的终端，不会启动新的进程\n\n`docker exec -it+container ID`  重新进入容器，在容器中打开新的终端，并且可以启动新的进程\n\n`docker cp+container ID:path_in_container target_path` 将容器中的文件拷贝到目标路径 \n\n*******\n\n## Docker镜像命令\n\n`docker pull ...` 拉取镜像\n\n`docker images[OPTIONS]` 查看本地镜像\n\n> OPTIONS说明：\n>\n> -a:列出本地所有的镜像（含中间映像层）\n>\n> -q:只显示镜像ID\n>\n> --digests:显示镜像的摘要信息\n>\n> --no-trunc:显示完整的镜像信息\n\n`docker search+image name[OPTIONS]` 搜索镜像\n\n> OPTIONS说明：\n>\n> --no-trunc:显示完整的镜像描述\n>\n> --automated:只列出automated build类型的镜像\n\n`docker pull+image name` 拉取某个镜像\n\n`docker rmi+image name/image ID` 删除某个镜像\n\n`docker rmi+image name/image ID1+image name/image ID2+...` 删除多个镜像\n\n`docker rmi -f $(docker images -qa)` 删除全部镜像\n\n`docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器ID 要创建的目标镜像名:[标签名]` 生成新镜像\n\n******\n\n## Docker数据卷\n\nFeatures：\n\n1. 数据卷可在容器之间共享或者重用数据\n2. 卷中的更改可以直接生效\n3. 数据卷中的更改不会包含在镜像的更新中\n4. 数据卷的生命周期一直持续到没有容器使用它为止\n\nCommands:\n\n`docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名` 在两个路径创建分别创建文件夹并使它们相关\n\n`docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名` 仅允许主机对数据卷内容进行修改，容器仅有读取数据卷内容的权限\n\n在Dockerfile中使用VOLUME指令\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t`VOLUME [\"/dataVolumeContainer1\",\"/dataVolumeContainer2\"]` 指定两个容器内部数据卷的地址\n\n`docker run -it --name ContainerName --volumes-from FatherName ImageName` 新建镜像并使其指定路径连接数据卷\n\n******\n\n## Dockerfile\n\n流程：\n\n1. 编写dockerfile文件\n\n2. docker build -t 新镜像名字:TAG\n\n3. docker run -it 新镜像名字:TAG\n\n4. 列出镜像的变更历史 docker history 镜像ID\n\n   重点：\n\n5. 每条保留字指令都必须为大写字母并且后面至少跟随一个参数\n\n6. #表示注释\n\n7. 每条指令都会创建一个新的镜像层，并对镜像进行提交  \n\nDocker执行Dockerfile的流程：\n\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器作出修改\n3. 提交一个新的镜像层\n4. docker基于新提交的镜像运行一个新容器\n5. 执行dockerfile中的下一条指令知道所有指令执行完成\n\nDockerfile保留字指令：\n\n> FROM 基础镜像；当前镜像基于哪个镜像\n>\n> MAINTAINER 镜像维护者的姓名和邮箱地质=址\n>\n> RUN 容器构建时所需命令\n>\n> EXPOSE 当前容器对外暴露的端口\n>\n> WORKDIR 指定在创建容器后，终端默认登陆的进来工作目录。不添加即为根目录\n>\n> ENV 用于在构建镜像过程中设置环境变量\n>\n> ADD 将宿主机目录下的文件拷贝进镜像且自动处理URL、解压tar压缩包\n>\n> COPY 拷贝文件和目录到镜像中，将从构建上下文目录中源路径的文件/目录复制到新的一层镜像内的目标路径位置\n>\n> VOLUME 容器数据卷，用于数据保存和持久化工作\n>\n> CMD 指定一个容器启动时要运行的命令。可以有多个CMD命令，但只有最后一个会生效，会被docker run之后的参数替代\n>\n> ENTRYPOINT 指定一  个容器启动时要运行的命令，指定容器启动程序及参数\n>\n> ONBUILD 当构建一个被继承的dockerfile时运行，父镜像在被子镜像继承后其onbuild被触发\n\n---\n---\n"},{"title":"Hello World","url":"/2021/04/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]