<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2021/04/02/Docker/</url>
    <content><![CDATA[<h1 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h1><p><code>service docker start</code>启动</p>
<h2 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h2><p><code>docker run[OPTIONS]IMAGE[COMMAND][ARG...]</code>新建并启动新的容器</p>
<blockquote>
<p>OPTIONS说明：</p>
<p>–name=”new name”:为容器指定一个名称</p>
<p>-d:后台运行容器并返回容器ID</p>
<p>-i:以交互模式运行容器</p>
<p>-t:为容器重新分配一个伪终端</p>
<p>-p:主机端口:docker容器端口</p>
<p>-P:随机分配端口</p>
</blockquote>
<p><code>docker ps[OPTIONS]</code>查看容器</p>
<blockquote>
<p>OPTIONS说明：</p>
<p>-a:列出当前所有活跃容器以及曾运行过的容器</p>
<p>-l:显示最近创建的容器</p>
<p>-n:显示最近n个创建的容器</p>
<p>-q:静默模式，只显示容器编号</p>
<p>–no-trunc:不截断输出</p>
</blockquote>
<p><code>exit</code>停止并退出当前容器</p>
<p><code>ctrl</code>+<code>P</code>+<code>Q</code>容器不停止退出</p>
<p><code>docker start+container name/container ID</code> 启动容器</p>
<p><code>docker restart+container name/container ID</code> 重新启动容器</p>
<p><code>docker stop+container name/container ID</code> 停止容器</p>
<p><code>docker kill+container name/container ID</code> 强制停止容器</p>
<p><code>docker rm+container name/container ID</code> 删除已停止的某一容器</p>
<p><code>docker -rm -f+container name/container ID</code> 删除正在运行的容器</p>
<p><code>docker logs -f -t --tail</code> -t加入时间戳 -f跟随最新的打印日志 –tail数字显示最后多少条</p>
<p><code>docker top+container ID</code> 查看容器内运行的进程</p>
<p><code>docker inspect+container ID</code> 查看容器内部细节</p>
<p><code>docker attach+container ID</code>  重新进入容器，启动命令的终端，不会启动新的进程</p>
<p><code>docker exec -it+container ID</code>  重新进入容器，在容器中打开新的终端，并且可以启动新的进程</p>
<p><code>docker cp+container ID:path_in_container target_path</code> 将容器中的文件拷贝到目标路径 </p>
<hr>
<h2 id="Docker镜像命令"><a href="#Docker镜像命令" class="headerlink" title="Docker镜像命令"></a>Docker镜像命令</h2><p><code>docker pull ...</code> 拉取镜像</p>
<p><code>docker images[OPTIONS]</code> 查看本地镜像</p>
<blockquote>
<p>OPTIONS说明：</p>
<p>-a:列出本地所有的镜像（含中间映像层）</p>
<p>-q:只显示镜像ID</p>
<p>–digests:显示镜像的摘要信息</p>
<p>–no-trunc:显示完整的镜像信息</p>
</blockquote>
<p><code>docker search+image name[OPTIONS]</code> 搜索镜像</p>
<blockquote>
<p>OPTIONS说明：</p>
<p>–no-trunc:显示完整的镜像描述</p>
<p>–automated:只列出automated build类型的镜像</p>
</blockquote>
<p><code>docker pull+image name</code> 拉取某个镜像</p>
<p><code>docker rmi+image name/image ID</code> 删除某个镜像</p>
<p><code>docker rmi+image name/image ID1+image name/image ID2+...</code> 删除多个镜像</p>
<p><code>docker rmi -f $(docker images -qa)</code> 删除全部镜像</p>
<p><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</code> 生成新镜像</p>
<hr>
<h2 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h2><p>Features：</p>
<ol>
<li>数据卷可在容器之间共享或者重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<p>Commands:</p>
<p><code>docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</code> 在两个路径创建分别创建文件夹并使它们相关</p>
<p><code>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code> 仅允许主机对数据卷内容进行修改，容器仅有读取数据卷内容的权限</p>
<p>在Dockerfile中使用VOLUME指令                                                                            <code>VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]</code> 指定两个容器内部数据卷的地址</p>
<p><code>docker run -it --name ContainerName --volumes-from FatherName ImageName</code> 新建镜像并使其指定路径连接数据卷</p>
<hr>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>流程：</p>
<ol>
<li><p>编写dockerfile文件</p>
</li>
<li><p>docker build -t 新镜像名字:TAG</p>
</li>
<li><p>docker run -it 新镜像名字:TAG</p>
</li>
<li><p>列出镜像的变更历史 docker history 镜像ID</p>
<p>重点：</p>
</li>
<li><p>每条保留字指令都必须为大写字母并且后面至少跟随一个参数</p>
</li>
<li><p>#表示注释</p>
</li>
<li><p>每条指令都会创建一个新的镜像层，并对镜像进行提交  </p>
</li>
</ol>
<p>Docker执行Dockerfile的流程：</p>
<ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>提交一个新的镜像层</li>
<li>docker基于新提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令知道所有指令执行完成</li>
</ol>
<p>Dockerfile保留字指令：</p>
<blockquote>
<p>FROM 基础镜像；当前镜像基于哪个镜像</p>
<p>MAINTAINER 镜像维护者的姓名和邮箱地质=址</p>
<p>RUN 容器构建时所需命令</p>
<p>EXPOSE 当前容器对外暴露的端口</p>
<p>WORKDIR 指定在创建容器后，终端默认登陆的进来工作目录。不添加即为根目录</p>
<p>ENV 用于在构建镜像过程中设置环境变量</p>
<p>ADD 将宿主机目录下的文件拷贝进镜像且自动处理URL、解压tar压缩包</p>
<p>COPY 拷贝文件和目录到镜像中，将从构建上下文目录中源路径的文件/目录复制到新的一层镜像内的目标路径位置</p>
<p>VOLUME 容器数据卷，用于数据保存和持久化工作</p>
<p>CMD 指定一个容器启动时要运行的命令。可以有多个CMD命令，但只有最后一个会生效，会被docker run之后的参数替代</p>
<p>ENTRYPOINT 指定一  个容器启动时要运行的命令，指定容器启动程序及参数</p>
<p>ONBUILD 当构建一个被继承的dockerfile时运行，父镜像在被子镜像继承后其onbuild被触发</p>
</blockquote>
<hr>
<hr>
]]></content>
  </entry>
</search>
